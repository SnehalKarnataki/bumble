<html>
  <head>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.23.2/full/pyodide.js"></script>
  </head>

  <body>
    <button id="connectButton" disabled onclick="runWebSocket()">Connect</button>
    <br />
    <br />
    <div>Output:</div>
    <textarea id="output" style="width: 100%;" rows="30" disabled></textarea>

    <script>
        function bufferToHex(buffer) {
            return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join('');
        }

        const output = document.getElementById("output");
        const code = document.getElementById("code");

        function addToOutput(s) {
            output.value += s + "\n";
        }

      output.value = "Initializing...\n";

      class PacketSource {
        constructor(pyodide) {
          this.parser = pyodide.runPython(`
            from bumble.transport.common import PacketParser
            class ProxiedPacketParser(PacketParser):
                def feed_data(self, js_data):
                  super().feed_data(bytes(js_data.to_py()))
            ProxiedPacketParser()
          `);
        }

        set_packet_sink(sink) {
          this.parser.set_packet_sink(sink);
        }

        data_received(data) {
          this.parser.feed_data(data);
        }
      }

      class PacketSink {
        constructor(writer) {
          this.writer = writer;
        }

        on_packet(packet) {
          const buffer = packet.toJs()
          console.log(`$$$ on_packet: ${bufferToHex(buffer)}`)
          // TODO: create an async queue here instead of blindly calling write without awaiting
          this.writer(buffer);
          packet.destroy()
        }
      }

      async function connectWebSocket(pyodide, hciWsUrl) {
        return new Promise((resolve, reject) => {
          let resolved = false;

          let ws = new WebSocket(hciWsUrl);
          ws.binaryType = "arraybuffer";

          ws.onopen = () => {
            console.log("WebSocket open");
            resolve({
              packet_source,
              packet_sink
            })
            resolved = true;
          }

          ws.onclose = () => {
            console.log("WebSocket close");
            if (!resolved) {
              reject(`Failed to connect to ${url}`)
            }
          }

          ws.onmessage = (event) => {
            console.log(`WebSocket message: ${bufferToHex(event.data)}`);
            packet_source.data_received(event.data);
          }

          const packet_source = new PacketSource(pyodide);
          const packet_sink = new PacketSink((packet) => ws.send(packet));
        })
      }

      async function runWebSocket() {
        let params = (new URL(document.location)).searchParams;
        let hciWsUrl = params.get("hci") || "ws://localhost:9922/hci";
        run(hciWsUrl);
      }

      async function run(hciWsUrl) {
          let pyodide = await pyodideReadyPromise;
          try {
              await pyodide.loadPackage("micropip");
              await pyodide.runPythonAsync(`
                import micropip
                package_list = micropip.list()
                print(package_list)
                await micropip.install("bumble-0.0.160.dev1+gd817f3f-py3-none-any.whl")
              `)

              const script = await(await fetch("scanner.py")).text()
              let output = await pyodide.runPythonAsync(script)
              addToOutput(output)

              let { packet_source, packet_sink } = await connectWebSocket(pyodide, hciWsUrl);
              const pythonMain = pyodide.globals.get('main')
              pythonResult = await pythonMain(packet_source, packet_sink)
              console.log(pythonResult)
              console.log('### done')
        } catch (err) {
          addToOutput(err);
        }
      }

      async function main() {
          // Init Pyodide
          let pyodide = await loadPyodide();
          console.log("Pyodide loaded");
          output.value += "Ready!\n"

          // Enable the Connect button
          document.getElementById("connectButton").disabled = false

          return pyodide;
      }

      let pyodideReadyPromise = main();
    </script>
  </body>
</html>
